# AI Todo Chatbot: A Spec-Driven, Event-Driven Microservices Project (Phase V: Advanced Cloud Deployment Ready)

This project is building a production-grade AI Todo Chatbot using a strict Spec-Driven Development (SDD) process. The system is architected as a scalable, event-driven, and cloud-native application composed of decoupled microservices, ready for advanced cloud deployment on Oracle Kubernetes Engine (OKE).

The project's principles and technical laws are defined in the [Project Constitution](/.specify/memory/constitution.md). All AI agents (Claude, Gemini, Copilot) are governed by [AGENTS.md](/AGENTS.md) to ensure a consistent Spec-Driven Development workflow.

## Core Architecture

This project is a distributed system of microservices that communicate asynchronously via a Kafka event backbone. All infrastructure interactions (e.g., messaging, state, secrets) are abstracted through **Dapr** sidecars, making the system portable and resilient across local (Minikube) and cloud (OKE) environments.

- **Event-Driven**: Services are decoupled and communicate via events (Kafka).
- **Microservices**: Each business domain (Frontend, API Gateway, Tasks, Notifications, Audit, WebSockets, Recurring Tasks) is an independent service.
- **Dapr-Enabled**: Dapr provides the abstraction layer for all infrastructure components (Pub/Sub, State Management, Secrets Management, Jobs API, Service Invocation).
- **Kubernetes-Native**: Deployed and managed using Helm charts on Kubernetes (Minikube locally, OKE in Oracle Cloud).
- **CI/CD**: Automated build and deployment pipelines using GitHub Actions.
- **Monitoring & Logging**: Comprehensive observability with Prometheus, Grafana, Loki, and Promtail.
- **Spec-Driven**: All code is generated by AI agents following a rigorous `Constitution -> Specify -> Plan -> Tasks -> Implement` workflow.

## Project Structure

The project is organized into independent services, each with its own logic and data, and supported by robust infrastructure configurations.

```
.
├── .github/              # GitHub Actions workflows for CI/CD
│   └── workflows/
├── .specify/             # SpecKit Plus configuration and templates
│   └── memory/
│       └── constitution.md # The supreme architectural law of the project
├── dapr/                 # Dapr component configurations
│   └── components/       # PubSub, State Store, Secret Store, Jobs API YAMLs
├── docs/                 # General project documentation (e.g., deployment guides)
├── events/               # Centralized Pydantic schemas for event payloads
├── helm/                 # Helm charts for deploying services to Kubernetes
│   ├── api-gateway/
│   ├── frontend/
│   ├── notification-service/
│   ├── audit-service/
│   ├── websocket-service/
│   └── recurring-task-service/
├── k8s/                  # Raw Kubernetes manifests for infrastructure and ingress
│   ├── application/      # Ingress and other application-level K8s resources
│   ├── infrastructure/   # Dapr Control Plane, Strimzi Kafka, Redis, PostgreSQL manifests/guides
│   └── monitoring/       # Prometheus, Grafana, Loki, Promtail manifests/guides
├── services/             # Independent microservices
│   ├── api-gateway/      # Handles API routing and potentially authentication
│   ├── frontend/         # Next.js web application
│   ├── tasks-service/    # Core service for task management (CRUD, events publishing)
│   ├── notification-service/ # Sends notifications for reminders
│   ├── audit-service/    # Logs all task-related events for auditing
│   ├── websocket-service/ # Manages real-time task updates for clients
│   └── recurring-task-service/ # Automatically creates next occurrences of recurring tasks
├── specs/                # Specifications, plans, and tasks for each feature
│   └── ...
├── AGENTS.md             # Guidelines for AI agents following Spec-Driven Development
└── CLAUDE.md             # Redirection to AGENTS.md for Claude Code
└── GEMINI.md             # Redirection to AGENTS.md for Gemini (if configured)
└── README.md             # This file
```

## Mandatory Tech Stack

- **Backend**: Python 3.11+ with FastAPI (async only)
- **Frontend**: Next.js
- **ORM**: SQLModel
- **Database**: PostgreSQL (Neon compatible)
- **Messaging**: Kafka (abstracted via Dapr Pub/Sub, self-hosted Strimzi or managed service like Redpanda Cloud)
- **State Management**: Redis (abstracted via Dapr State Store)
- **Service Abstraction**: Dapr (Pub/Sub, State, Secrets, Jobs API, Service Invocation)
- **Containerization**: Docker
- **Orchestration**: Kubernetes (Oracle Kubernetes Engine - OKE)
- **Infrastructure as Code**: Helm Charts
- **CI/CD**: GitHub Actions
- **Monitoring**: Prometheus
- **Visualization**: Grafana
- **Logging**: Loki & Promtail
- **Development Methodology**: Spec-Driven Development (SDD) with AI Agents

## Implemented Features (Design/Code Structure)

This project is structured to implement the following features:
- **Core Task Management**: Create, Read, Update, Delete tasks.
- **Event-Driven Architecture**: Tasks service publishes events, other services subscribe.
- **Notifications**: Dedicated service for sending reminders based on events.
- **Audit Logging**: Dedicated service for logging all task events.
- **Real-time Synchronization**: WebSocket service for broadcasting task updates to clients.
- **Recurring Tasks**: Dedicated service for managing recurring task occurrences.
- **Dapr Integration**: Full Dapr building blocks for Pub/Sub, State, Secrets, Jobs API.

*(Note: While the code structure for these features and their Dapr integration is in place, the full business logic for advanced features like Recurring Tasks, Due Dates & Reminders, Priorities, Tags, Search, Filter, Sort needs further implementation within the respective services.)*

## Local Development Setup

This section outlines how to set up and run the project locally using Minikube and Dapr.

### Prerequisites

*   [Docker Desktop](https://www.docker.com/products/docker-desktop/) (includes Docker, Kubernetes, and `kubectl`)
*   [Dapr CLI](https://docs.dapr.io/getting-started/install-dapr-cli/)
*   [Helm CLI](https://helm.sh/docs/intro/install/)
*   [Minikube](https://minikube.sigs.k8s.io/docs/start/) (if not using Docker Desktop's built-in Kubernetes)

### Steps

1.  **Start Minikube / Enable Docker Desktop Kubernetes:**
    Ensure your local Kubernetes cluster is running.
    ```bash
    minikube start # If using Minikube
    # Or ensure Kubernetes is enabled in Docker Desktop settings
    ```

2.  **Initialize Dapr on Minikube:**
    ```bash
    dapr init -k
    ```

3.  **Deploy Local Infrastructure (Kafka, Redis, PostgreSQL):**
    You can use `docker-compose` for local development or deploy them to Minikube.
    *   **Kafka (Redpanda Docker):** Recommended for local development for simplicity.
        ```bash
        # Instructions for running Redpanda via Docker or docker-compose
        ```
    *   **Redis & PostgreSQL:**
        ```bash
        kubectl apply -f k8s/infrastructure/redis/redis-deployment.yaml
        kubectl apply -f k8s/infrastructure/redis/redis-service.yaml
        kubectl apply -f k8s/infrastructure/postgresql/postgres-pvc.yaml
        kubectl apply -f k8s/infrastructure/postgresql/postgres-deployment.yaml
        kubectl apply -f k8s/infrastructure/postgresql/postgres-service.yaml
        ```

4.  **Deploy Dapr Components Locally:**
    ```bash
    kubectl apply -f dapr/components/
    ```

5.  **Build Docker Images (optional for local, or use `dapr run`):**
    If you're running services with `dapr run`, you might not need to build images explicitly.

6.  **Run Services with Dapr Sidecars (Example for tasks-service):**
    ```bash
    dapr run --app-id tasks-service --app-port 8000 --dapr-http-port 3500 --dapr-grpc-port 50001 -- python -m uvicorn services.tasks-service.app.main:app --host 0.0.0.0 --port 8000
    ```
    Repeat for all services, adjusting `app-id` and port.

## Cloud Deployment (Oracle Kubernetes Engine - OKE)

This project is configured for deployment to Oracle Kubernetes Engine (OKE).

### Prerequisites

*   An OKE cluster up and running.
*   `kubectl` configured to connect to your OKE cluster.
*   `helm` CLI installed.
*   GitHub repository with configured GitHub Actions secrets for OCI authentication (see CI/CD section).

### Deployment Steps (via CI/CD)

The recommended way to deploy to OKE is via the GitHub Actions CD workflow.

1.  **Set up OCI Authentication Secrets:**
    Configure the following secrets in your GitHub repository (`Settings -> Secrets -> Actions`):
    *   `OCI_API_KEY_FINGERPRINT`
    *   `OCI_API_KEY_PRIVATE_KEY` (The content of your API private key file)
    *   `OCI_TENANCY_ID`
    *   `OCI_USER_ID`
    *   `OCI_REGION`
    *   `OKE_CLUSTER_OCID` (The OCID of your OKE cluster)
    Refer to Oracle Cloud documentation for [GitHub Actions OCI integration](https://docs.oracle.com/en-us/iaas/Content/API/Concepts/sdk_github_actions.htm).

2.  **Push to `main` branch:**
    Once the CI workflow (builds Docker images) completes successfully, the CD workflow will automatically trigger to deploy your application to the OKE cluster.

### Manual Deployment (for debugging or initial setup)

1.  **Install Dapr Control Plane:**
    Follow the instructions in [`k8s/infrastructure/dapr-install-guide.md`](/k8s/infrastructure/dapr-install-guide.md).

2.  **Deploy Infrastructure Components:**
    *   **Strimzi Kafka:** Follow instructions in [`k8s/infrastructure/strimzi-kafka/01-strimzi-operator.yaml`](/k8s/infrastructure/strimzi-kafka/01-strimzi-operator.yaml) and then apply [`k8s/infrastructure/strimzi-kafka/02-kafka-cluster.yaml`](/k8s/infrastructure/strimzi-kafka/02-kafka-cluster.yaml).
    *   **Redis:** Apply manifests in [`k8s/infrastructure/redis/`](/k8s/infrastructure/redis/).
    *   **PostgreSQL:** Apply manifests in [`k8s/infrastructure/postgresql/`](/k8s/infrastructure/postgresql/).

3.  **Deploy Dapr Components:**
    Apply the Dapr component YAMLs:
    ```bash
    kubectl apply -f dapr/components/
    ```

4.  **Deploy Application Helm Charts:**
    Install each application service using its Helm chart:
    ```bash
    helm upgrade --install frontend ./helm/frontend --namespace default
    helm upgrade --install backend ./helm/backend --namespace default
    helm upgrade --install notification-service ./helm/notification-service --namespace default
    helm upgrade --install audit-service ./helm/audit-service --namespace default
    helm upgrade --install websocket-service ./helm/websocket-service --namespace default
    helm upgrade --install recurring-task-service ./helm/recurring-task-service --namespace default
    ```

5.  **Deploy Ingress:**
    ```bash
    kubectl apply -f k8s/application/ingress.yaml
    ```

## CI/CD Pipeline (GitHub Actions)

The project utilizes GitHub Actions for automated Continuous Integration and Continuous Deployment.

-   **[`ci.yaml`](/.github/workflows/ci.yaml)**:
    *   Triggers on `push` and `pull_request` to `main` branch.
    *   Builds Docker images for all microservices.
    *   Pushes images to GitHub Container Registry (GHCR).
-   **[`cd.yaml`](/.github/workflows/cd.yaml)**:
    *   Triggers on `push` to `main` and upon successful completion of the `ci.yaml` workflow.
    *   Authenticates with OCI.
    *   Configures `kubectl` for OKE.
    *   Installs Dapr Control Plane (if not present).
    *   Deploys infrastructure components (Strimzi Kafka, Redis, PostgreSQL).
    *   Deploys Dapr components.
    *   Deploys application Helm charts.
    *   Deploys Kubernetes Ingress.

## Monitoring & Logging

The project is configured with Prometheus, Grafana, Loki, and Promtail for comprehensive observability.

-   **Prometheus**: For metrics collection and alerting. Follow the [`install-guide.md`](/k8s/monitoring/prometheus/install-guide.md) to set up Prometheus Operator.
-   **Grafana**: For data visualization and dashboards. Access instructions are in [`access-guide.md`](/k8s/monitoring/grafana/access-guide.md).
-   **Loki & Promtail**: For centralized log aggregation. Follow the [`install-guide.md`](/k8s/monitoring/logging/install-guide.md) to set up Loki and Promtail.

## Contribution & Development

This project follows a strict Spec-Driven Development (SDD) methodology using AI agents. All contributions must adhere to the guidelines outlined in [AGENTS.md](/AGENTS.md).

### Workflow

1.  **Define Specification**: Update `specs/<feature-name>/spec.md` with requirements, user journeys, and acceptance criteria.
2.  **Create Plan**: Develop `specs/<feature-name>/plan.md` outlining the architectural approach.
3.  **Break into Tasks**: Define atomic, testable work units in `specs/<feature-name>/tasks.md`.
4.  **Implement**: Write code based on defined tasks.

Refer to [AGENTS.md](/AGENTS.md) for detailed agent behavior and workflow.
